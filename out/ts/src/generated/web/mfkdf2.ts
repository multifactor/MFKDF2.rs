// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import * as wasmBundle from "./wasm-bindgen/index.js";
import {
  type UniffiByteArray, 
  AbstractFfiConverterByteArray, 
  FfiConverterArray, 
  FfiConverterArrayBuffer, 
  FfiConverterBool, 
  FfiConverterInt32, 
  FfiConverterMap, 
  FfiConverterOptional, 
  FfiConverterUInt32, 
  FfiConverterUInt8, 
  RustBuffer, 
  UniffiEnum, 
  UniffiError, 
  UniffiInternalError, 
  UniffiRustCaller, 
  uniffiCreateFfiConverterString, 
  uniffiCreateRecord, 
  uniffiRustCallAsync, 
  uniffiTypeNameSymbol, 
  variantOrdinalSymbol } from "uniffi-bindgen-react-native";

// Get converters from the other files, if any.
const nativeModule = () => wasmBundle;
const uniffiCaller = new UniffiRustCaller(() => new wasmBundle.RustCallStatus());

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== "object" ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== "production" ||
  false;
// Public interface members begin here.

export async function deriveKey(policy: Policy, factors: Map<string, Mfkdf2Factor>, asyncOpts_?: { signal: AbortSignal }): Promise<Mfkdf2DerivedKey> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
        return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller,
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_mfkdf2_fn_func_derive_key(FfiConverterTypePolicy.lower(policy),FfiConverterMapStringTypeMFKDF2Factor.lower(factors)
                );
            },
            /*pollFunc:*/ nativeModule().ubrn_ffi_mfkdf2_rust_future_poll_rust_buffer,
            /*cancelFunc:*/ nativeModule().ubrn_ffi_mfkdf2_rust_future_cancel_rust_buffer,
            /*completeFunc:*/ nativeModule().ubrn_ffi_mfkdf2_rust_future_complete_rust_buffer,
            /*freeFunc:*/ nativeModule().ubrn_ffi_mfkdf2_rust_future_free_rust_buffer,
            /*liftFunc:*/ FfiConverterTypeMFKDF2DerivedKey.lift.bind(FfiConverterTypeMFKDF2DerivedKey),
            /*liftString:*/ FfiConverterString.lift,
            /*asyncOpts:*/ asyncOpts_,
            /*errorHandler:*/ FfiConverterTypeMFKDF2Error.lift.bind(FfiConverterTypeMFKDF2Error)
        );
    } catch (__error: any) {
        if (uniffiIsDebug && __error instanceof Error) {
            __error.stack = __stack;
        }
        throw __error;
    }
    }
export function derivePassword(password: string): Mfkdf2Factor /*throws*/ {
    return FfiConverterTypeMFKDF2Factor.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeMFKDF2Error.lift.bind(FfiConverterTypeMFKDF2Error),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_mfkdf2_fn_func_derive_password(
        FfiConverterString.lower(password),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
export function hotp(code: /*u32*/number): Mfkdf2Factor /*throws*/ {
    return FfiConverterTypeMFKDF2Factor.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeMFKDF2Error.lift.bind(FfiConverterTypeMFKDF2Error),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_mfkdf2_fn_func_hotp(
        FfiConverterUInt32.lower(code),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
export async function key(factors: Array<Mfkdf2Factor>, options: Mfkdf2Options, asyncOpts_?: { signal: AbortSignal }): Promise<Mfkdf2DerivedKey> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
        return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller,
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_mfkdf2_fn_func_key(FfiConverterArrayTypeMFKDF2Factor.lower(factors),FfiConverterTypeMFKDF2Options.lower(options)
                );
            },
            /*pollFunc:*/ nativeModule().ubrn_ffi_mfkdf2_rust_future_poll_rust_buffer,
            /*cancelFunc:*/ nativeModule().ubrn_ffi_mfkdf2_rust_future_cancel_rust_buffer,
            /*completeFunc:*/ nativeModule().ubrn_ffi_mfkdf2_rust_future_complete_rust_buffer,
            /*freeFunc:*/ nativeModule().ubrn_ffi_mfkdf2_rust_future_free_rust_buffer,
            /*liftFunc:*/ FfiConverterTypeMFKDF2DerivedKey.lift.bind(FfiConverterTypeMFKDF2DerivedKey),
            /*liftString:*/ FfiConverterString.lift,
            /*asyncOpts:*/ asyncOpts_,
            /*errorHandler:*/ FfiConverterTypeMFKDF2Error.lift.bind(FfiConverterTypeMFKDF2Error)
        );
    } catch (__error: any) {
        if (uniffiIsDebug && __error instanceof Error) {
            __error.stack = __stack;
        }
        throw __error;
    }
    }
export function setupPassword(password: string, options: PasswordOptions): Mfkdf2Factor /*throws*/ {
    return FfiConverterTypeMFKDF2Factor.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeMFKDF2Error.lift.bind(FfiConverterTypeMFKDF2Error),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_mfkdf2_fn_func_setup_password(
        FfiConverterString.lower(password),
        FfiConverterTypePasswordOptions.lower(options),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }








export type Hotp = {
    options: HotpOptions,
    params: string,
    code: /*u32*/number,
    target: /*u32*/number
}

/**
 * Generated factory for {@link Hotp} record objects.
 */
export const Hotp = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<Hotp, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link Hotp}, with defaults specified
         * in Rust, in the {@link mfkdf2} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link Hotp}, with defaults specified
         * in Rust, in the {@link mfkdf2} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link mfkdf2} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<Hotp>,
    });
})();

const FfiConverterTypeHOTP = (() => {
    type TypeName = Hotp;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                options: FfiConverterTypeHOTPOptions.read(from), 
                params: FfiConverterString.read(from), 
                code: FfiConverterUInt32.read(from), 
                target: FfiConverterUInt32.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterTypeHOTPOptions.write(value.options, into);
            FfiConverterString.write(value.params, into);
            FfiConverterUInt32.write(value.code, into);
            FfiConverterUInt32.write(value.target, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterTypeHOTPOptions.allocationSize(value.options) + 
            FfiConverterString.allocationSize(value.params) + 
            FfiConverterUInt32.allocationSize(value.code) + 
            FfiConverterUInt32.allocationSize(value.target);
            
        }
    };
    return new FFIConverter();
})();


export type HotpOptions = {
    id: string | undefined,
    secret: ArrayBuffer | undefined,
    digits: /*u8*/number,
    hash: HotpHash,
    issuer: string,
    label: string
}

/**
 * Generated factory for {@link HotpOptions} record objects.
 */
export const HotpOptions = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<HotpOptions, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link HotpOptions}, with defaults specified
         * in Rust, in the {@link mfkdf2} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link HotpOptions}, with defaults specified
         * in Rust, in the {@link mfkdf2} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link mfkdf2} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<HotpOptions>,
    });
})();

const FfiConverterTypeHOTPOptions = (() => {
    type TypeName = HotpOptions;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                id: FfiConverterOptionalString.read(from), 
                secret: FfiConverterOptionalArrayBuffer.read(from), 
                digits: FfiConverterUInt8.read(from), 
                hash: FfiConverterTypeHOTPHash.read(from), 
                issuer: FfiConverterString.read(from), 
                label: FfiConverterString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterOptionalString.write(value.id, into);
            FfiConverterOptionalArrayBuffer.write(value.secret, into);
            FfiConverterUInt8.write(value.digits, into);
            FfiConverterTypeHOTPHash.write(value.hash, into);
            FfiConverterString.write(value.issuer, into);
            FfiConverterString.write(value.label, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterOptionalString.allocationSize(value.id) + 
            FfiConverterOptionalArrayBuffer.allocationSize(value.secret) + 
            FfiConverterUInt8.allocationSize(value.digits) + 
            FfiConverterTypeHOTPHash.allocationSize(value.hash) + 
            FfiConverterString.allocationSize(value.issuer) + 
            FfiConverterString.allocationSize(value.label);
            
        }
    };
    return new FFIConverter();
})();


export type Mfkdf2DerivedKey = {
    policy: Policy,
    key: ArrayBuffer,
    secret: ArrayBuffer,
    shares: Array<ArrayBuffer>,
    outputs: Array<string>,
    entropy: Mfkdf2Entropy
}

/**
 * Generated factory for {@link Mfkdf2DerivedKey} record objects.
 */
export const Mfkdf2DerivedKey = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<Mfkdf2DerivedKey, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link Mfkdf2DerivedKey}, with defaults specified
         * in Rust, in the {@link mfkdf2} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link Mfkdf2DerivedKey}, with defaults specified
         * in Rust, in the {@link mfkdf2} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link mfkdf2} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<Mfkdf2DerivedKey>,
    });
})();

const FfiConverterTypeMFKDF2DerivedKey = (() => {
    type TypeName = Mfkdf2DerivedKey;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                policy: FfiConverterTypePolicy.read(from), 
                key: FfiConverterArrayBuffer.read(from), 
                secret: FfiConverterArrayBuffer.read(from), 
                shares: FfiConverterArrayArrayBuffer.read(from), 
                outputs: FfiConverterArrayString.read(from), 
                entropy: FfiConverterTypeMFKDF2Entropy.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterTypePolicy.write(value.policy, into);
            FfiConverterArrayBuffer.write(value.key, into);
            FfiConverterArrayBuffer.write(value.secret, into);
            FfiConverterArrayArrayBuffer.write(value.shares, into);
            FfiConverterArrayString.write(value.outputs, into);
            FfiConverterTypeMFKDF2Entropy.write(value.entropy, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterTypePolicy.allocationSize(value.policy) + 
            FfiConverterArrayBuffer.allocationSize(value.key) + 
            FfiConverterArrayBuffer.allocationSize(value.secret) + 
            FfiConverterArrayArrayBuffer.allocationSize(value.shares) + 
            FfiConverterArrayString.allocationSize(value.outputs) + 
            FfiConverterTypeMFKDF2Entropy.allocationSize(value.entropy);
            
        }
    };
    return new FFIConverter();
})();


export type Mfkdf2Entropy = {
    real: /*u32*/number,
    theoretical: /*u32*/number
}

/**
 * Generated factory for {@link Mfkdf2Entropy} record objects.
 */
export const Mfkdf2Entropy = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<Mfkdf2Entropy, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link Mfkdf2Entropy}, with defaults specified
         * in Rust, in the {@link mfkdf2} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link Mfkdf2Entropy}, with defaults specified
         * in Rust, in the {@link mfkdf2} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link mfkdf2} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<Mfkdf2Entropy>,
    });
})();

const FfiConverterTypeMFKDF2Entropy = (() => {
    type TypeName = Mfkdf2Entropy;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                real: FfiConverterUInt32.read(from), 
                theoretical: FfiConverterUInt32.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterUInt32.write(value.real, into);
            FfiConverterUInt32.write(value.theoretical, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterUInt32.allocationSize(value.real) + 
            FfiConverterUInt32.allocationSize(value.theoretical);
            
        }
    };
    return new FFIConverter();
})();


export type Mfkdf2Factor = {
    id: string | undefined,
    factorType: FactorType,
    salt: ArrayBuffer,
    entropy: /*u32*/number | undefined
}

/**
 * Generated factory for {@link Mfkdf2Factor} record objects.
 */
export const Mfkdf2Factor = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<Mfkdf2Factor, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link Mfkdf2Factor}, with defaults specified
         * in Rust, in the {@link mfkdf2} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link Mfkdf2Factor}, with defaults specified
         * in Rust, in the {@link mfkdf2} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link mfkdf2} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<Mfkdf2Factor>,
    });
})();

const FfiConverterTypeMFKDF2Factor = (() => {
    type TypeName = Mfkdf2Factor;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                id: FfiConverterOptionalString.read(from), 
                factorType: FfiConverterTypeFactorType.read(from), 
                salt: FfiConverterArrayBuffer.read(from), 
                entropy: FfiConverterOptionalUInt32.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterOptionalString.write(value.id, into);
            FfiConverterTypeFactorType.write(value.factorType, into);
            FfiConverterArrayBuffer.write(value.salt, into);
            FfiConverterOptionalUInt32.write(value.entropy, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterOptionalString.allocationSize(value.id) + 
            FfiConverterTypeFactorType.allocationSize(value.factorType) + 
            FfiConverterArrayBuffer.allocationSize(value.salt) + 
            FfiConverterOptionalUInt32.allocationSize(value.entropy);
            
        }
    };
    return new FFIConverter();
})();


export type Mfkdf2Options = {
    id: string | undefined,
    threshold: /*u8*/number | undefined,
    salt: ArrayBuffer | undefined
}

/**
 * Generated factory for {@link Mfkdf2Options} record objects.
 */
export const Mfkdf2Options = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<Mfkdf2Options, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link Mfkdf2Options}, with defaults specified
         * in Rust, in the {@link mfkdf2} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link Mfkdf2Options}, with defaults specified
         * in Rust, in the {@link mfkdf2} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link mfkdf2} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<Mfkdf2Options>,
    });
})();

const FfiConverterTypeMFKDF2Options = (() => {
    type TypeName = Mfkdf2Options;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                id: FfiConverterOptionalString.read(from), 
                threshold: FfiConverterOptionalUInt8.read(from), 
                salt: FfiConverterOptionalArrayBuffer.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterOptionalString.write(value.id, into);
            FfiConverterOptionalUInt8.write(value.threshold, into);
            FfiConverterOptionalArrayBuffer.write(value.salt, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterOptionalString.allocationSize(value.id) + 
            FfiConverterOptionalUInt8.allocationSize(value.threshold) + 
            FfiConverterOptionalArrayBuffer.allocationSize(value.salt);
            
        }
    };
    return new FFIConverter();
})();


export type Password = {
    password: string
}

/**
 * Generated factory for {@link Password} record objects.
 */
export const Password = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<Password, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link Password}, with defaults specified
         * in Rust, in the {@link mfkdf2} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link Password}, with defaults specified
         * in Rust, in the {@link mfkdf2} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link mfkdf2} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<Password>,
    });
})();

const FfiConverterTypePassword = (() => {
    type TypeName = Password;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                password: FfiConverterString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.password, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.password);
            
        }
    };
    return new FFIConverter();
})();


export type PasswordOptions = {
    id: string | undefined
}

/**
 * Generated factory for {@link PasswordOptions} record objects.
 */
export const PasswordOptions = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<PasswordOptions, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link PasswordOptions}, with defaults specified
         * in Rust, in the {@link mfkdf2} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link PasswordOptions}, with defaults specified
         * in Rust, in the {@link mfkdf2} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link mfkdf2} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<PasswordOptions>,
    });
})();

const FfiConverterTypePasswordOptions = (() => {
    type TypeName = PasswordOptions;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                id: FfiConverterOptionalString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterOptionalString.write(value.id, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterOptionalString.allocationSize(value.id);
            
        }
    };
    return new FFIConverter();
})();


export type Policy = {
    schema: string,
    id: string,
    threshold: /*u8*/number,
    salt: string,
    factors: Array<PolicyFactor>,
    hmac: string
}

/**
 * Generated factory for {@link Policy} record objects.
 */
export const Policy = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<Policy, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link Policy}, with defaults specified
         * in Rust, in the {@link mfkdf2} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link Policy}, with defaults specified
         * in Rust, in the {@link mfkdf2} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link mfkdf2} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<Policy>,
    });
})();

const FfiConverterTypePolicy = (() => {
    type TypeName = Policy;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                schema: FfiConverterString.read(from), 
                id: FfiConverterString.read(from), 
                threshold: FfiConverterUInt8.read(from), 
                salt: FfiConverterString.read(from), 
                factors: FfiConverterArrayTypePolicyFactor.read(from), 
                hmac: FfiConverterString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.schema, into);
            FfiConverterString.write(value.id, into);
            FfiConverterUInt8.write(value.threshold, into);
            FfiConverterString.write(value.salt, into);
            FfiConverterArrayTypePolicyFactor.write(value.factors, into);
            FfiConverterString.write(value.hmac, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.schema) + 
            FfiConverterString.allocationSize(value.id) + 
            FfiConverterUInt8.allocationSize(value.threshold) + 
            FfiConverterString.allocationSize(value.salt) + 
            FfiConverterArrayTypePolicyFactor.allocationSize(value.factors) + 
            FfiConverterString.allocationSize(value.hmac);
            
        }
    };
    return new FFIConverter();
})();


export type PolicyFactor = {
    id: string,
    kind: string,
    pad: string,
    salt: string,
    key: ArrayBuffer,
    secret: string,
    params: string
}

/**
 * Generated factory for {@link PolicyFactor} record objects.
 */
export const PolicyFactor = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<PolicyFactor, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link PolicyFactor}, with defaults specified
         * in Rust, in the {@link mfkdf2} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link PolicyFactor}, with defaults specified
         * in Rust, in the {@link mfkdf2} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link mfkdf2} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<PolicyFactor>,
    });
})();

const FfiConverterTypePolicyFactor = (() => {
    type TypeName = PolicyFactor;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                id: FfiConverterString.read(from), 
                kind: FfiConverterString.read(from), 
                pad: FfiConverterString.read(from), 
                salt: FfiConverterString.read(from), 
                key: FfiConverterArrayBuffer.read(from), 
                secret: FfiConverterString.read(from), 
                params: FfiConverterString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.id, into);
            FfiConverterString.write(value.kind, into);
            FfiConverterString.write(value.pad, into);
            FfiConverterString.write(value.salt, into);
            FfiConverterArrayBuffer.write(value.key, into);
            FfiConverterString.write(value.secret, into);
            FfiConverterString.write(value.params, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.id) + 
            FfiConverterString.allocationSize(value.kind) + 
            FfiConverterString.allocationSize(value.pad) + 
            FfiConverterString.allocationSize(value.salt) + 
            FfiConverterArrayBuffer.allocationSize(value.key) + 
            FfiConverterString.allocationSize(value.secret) + 
            FfiConverterString.allocationSize(value.params);
            
        }
    };
    return new FFIConverter();
})();


const stringConverter = (() => {
    const encoder = new TextEncoder();
    const decoder = new TextDecoder();
    return {
        stringToBytes: (s: string) => encoder.encode(s),
        bytesToString: (ab: UniffiByteArray) => decoder.decode(ab),
        stringByteLength: (s: string) => encoder.encode(s).byteLength,
    };
})();
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);






// Enum: FactorType
export enum FactorType_Tags {
    Password = "Password",
    Hotp = "HOTP"
}
export const FactorType = (() => {
    

    type Password__interface = {
        tag: FactorType_Tags.Password;
        inner: Readonly<
[Password
]>
    };

    
    class Password_ extends UniffiEnum implements Password__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "FactorType";
        readonly tag = FactorType_Tags.Password;
        readonly inner: Readonly<
[Password
]>;
        constructor(v0: Password) {
            super("FactorType", "Password");
            this.inner = Object.freeze([v0]);
        }

        static new(v0: Password): Password_ {
            return new Password_(v0);
        }

        static instanceOf(obj: any): obj is Password_ {
            return obj.tag === FactorType_Tags.Password;
        }

        

    }
    

    type Hotp__interface = {
        tag: FactorType_Tags.Hotp;
        inner: Readonly<
[Hotp
]>
    };

    
    class Hotp_ extends UniffiEnum implements Hotp__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "FactorType";
        readonly tag = FactorType_Tags.Hotp;
        readonly inner: Readonly<
[Hotp
]>;
        constructor(v0: Hotp) {
            super("FactorType", "Hotp");
            this.inner = Object.freeze([v0]);
        }

        static new(v0: Hotp): Hotp_ {
            return new Hotp_(v0);
        }

        static instanceOf(obj: any): obj is Hotp_ {
            return obj.tag === FactorType_Tags.Hotp;
        }

        

    }

    function instanceOf(obj: any): obj is FactorType {
        return obj[uniffiTypeNameSymbol] === "FactorType";
    }

    return Object.freeze({
        instanceOf,
  Password: Password_, 
  Hotp: Hotp_
    });

})();



export type FactorType = InstanceType<
    typeof FactorType[keyof Omit<typeof FactorType, 'instanceOf'>]
>;

// FfiConverter for enum FactorType
const FfiConverterTypeFactorType = (() => {
    const ordinalConverter = FfiConverterInt32;
    type TypeName = FactorType;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            switch (ordinalConverter.read(from)) {
                case 1: return new FactorType.Password(FfiConverterTypePassword.read(from));
                case 2: return new FactorType.Hotp(FfiConverterTypeHOTP.read(from));
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value: TypeName, into: RustBuffer): void {
            switch (value.tag) {
                case FactorType_Tags.Password: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterTypePassword.write(inner[0], into);
                    return;
                }
                case FactorType_Tags.Hotp: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterTypeHOTP.write(inner[0], into);
                    return;
                }
                default:
                    // Throwing from here means that FactorType_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value: TypeName): number {
            switch (value.tag) {
                case FactorType_Tags.Password: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterTypePassword.allocationSize(inner[0]);
                    return size;
                }
                case FactorType_Tags.Hotp: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterTypeHOTP.allocationSize(inner[0]);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();



export enum HotpHash {
    Sha1,
    Sha256,
    Sha512
}

const FfiConverterTypeHOTPHash = (() => {
    const ordinalConverter = FfiConverterInt32;
    type TypeName = HotpHash;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            switch (ordinalConverter.read(from)) {
                case 1: return HotpHash.Sha1;
                case 2: return HotpHash.Sha256;
                case 3: return HotpHash.Sha512;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value: TypeName, into: RustBuffer): void {
            switch (value) {
                case HotpHash.Sha1: return ordinalConverter.write(1, into);
                case HotpHash.Sha256: return ordinalConverter.write(2, into);
                case HotpHash.Sha512: return ordinalConverter.write(3, into);
            }
        }
        allocationSize(value: TypeName): number {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();






// Flat error type: Mfkdf2Error
export enum Mfkdf2Error_Tags {
    PasswordEmpty = "PasswordEmpty",
    AnswerEmpty = "AnswerEmpty",
    InvalidThreshold = "InvalidThreshold",
    MissingFactorId = "MissingFactorId",
    DuplicateFactorId = "DuplicateFactorId",
    DecodeError = "DecodeError",
    TryFromVecError = "TryFromVecError",
    ShareRecoveryError = "ShareRecoveryError",
    InvalidHmacKey = "InvalidHmacKey",
    InvalidHotpDigits = "InvalidHOTPDigits",
    Argon2Error = "Argon2Error",
    SerializeError = "SerializeError"
}
export const Mfkdf2Error = (() => {
    class PasswordEmpty extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [uniffiTypeNameSymbol]: string = "Mfkdf2Error";
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [variantOrdinalSymbol] = 1;

        public readonly tag = Mfkdf2Error_Tags.PasswordEmpty;

        constructor(message: string) {
            super("Mfkdf2Error", "PasswordEmpty", message);
        }

        static instanceOf(e: any): e is PasswordEmpty {
            return (
                instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1
            );
        }
    }
    class AnswerEmpty extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [uniffiTypeNameSymbol]: string = "Mfkdf2Error";
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [variantOrdinalSymbol] = 2;

        public readonly tag = Mfkdf2Error_Tags.AnswerEmpty;

        constructor(message: string) {
            super("Mfkdf2Error", "AnswerEmpty", message);
        }

        static instanceOf(e: any): e is AnswerEmpty {
            return (
                instanceOf(e) && (e as any)[variantOrdinalSymbol] === 2
            );
        }
    }
    class InvalidThreshold extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [uniffiTypeNameSymbol]: string = "Mfkdf2Error";
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [variantOrdinalSymbol] = 3;

        public readonly tag = Mfkdf2Error_Tags.InvalidThreshold;

        constructor(message: string) {
            super("Mfkdf2Error", "InvalidThreshold", message);
        }

        static instanceOf(e: any): e is InvalidThreshold {
            return (
                instanceOf(e) && (e as any)[variantOrdinalSymbol] === 3
            );
        }
    }
    class MissingFactorId extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [uniffiTypeNameSymbol]: string = "Mfkdf2Error";
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [variantOrdinalSymbol] = 4;

        public readonly tag = Mfkdf2Error_Tags.MissingFactorId;

        constructor(message: string) {
            super("Mfkdf2Error", "MissingFactorId", message);
        }

        static instanceOf(e: any): e is MissingFactorId {
            return (
                instanceOf(e) && (e as any)[variantOrdinalSymbol] === 4
            );
        }
    }
    class DuplicateFactorId extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [uniffiTypeNameSymbol]: string = "Mfkdf2Error";
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [variantOrdinalSymbol] = 5;

        public readonly tag = Mfkdf2Error_Tags.DuplicateFactorId;

        constructor(message: string) {
            super("Mfkdf2Error", "DuplicateFactorId", message);
        }

        static instanceOf(e: any): e is DuplicateFactorId {
            return (
                instanceOf(e) && (e as any)[variantOrdinalSymbol] === 5
            );
        }
    }
    class DecodeError extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [uniffiTypeNameSymbol]: string = "Mfkdf2Error";
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [variantOrdinalSymbol] = 6;

        public readonly tag = Mfkdf2Error_Tags.DecodeError;

        constructor(message: string) {
            super("Mfkdf2Error", "DecodeError", message);
        }

        static instanceOf(e: any): e is DecodeError {
            return (
                instanceOf(e) && (e as any)[variantOrdinalSymbol] === 6
            );
        }
    }
    class TryFromVecError extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [uniffiTypeNameSymbol]: string = "Mfkdf2Error";
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [variantOrdinalSymbol] = 7;

        public readonly tag = Mfkdf2Error_Tags.TryFromVecError;

        constructor(message: string) {
            super("Mfkdf2Error", "TryFromVecError", message);
        }

        static instanceOf(e: any): e is TryFromVecError {
            return (
                instanceOf(e) && (e as any)[variantOrdinalSymbol] === 7
            );
        }
    }
    class ShareRecoveryError extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [uniffiTypeNameSymbol]: string = "Mfkdf2Error";
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [variantOrdinalSymbol] = 8;

        public readonly tag = Mfkdf2Error_Tags.ShareRecoveryError;

        constructor(message: string) {
            super("Mfkdf2Error", "ShareRecoveryError", message);
        }

        static instanceOf(e: any): e is ShareRecoveryError {
            return (
                instanceOf(e) && (e as any)[variantOrdinalSymbol] === 8
            );
        }
    }
    class InvalidHmacKey extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [uniffiTypeNameSymbol]: string = "Mfkdf2Error";
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [variantOrdinalSymbol] = 9;

        public readonly tag = Mfkdf2Error_Tags.InvalidHmacKey;

        constructor(message: string) {
            super("Mfkdf2Error", "InvalidHmacKey", message);
        }

        static instanceOf(e: any): e is InvalidHmacKey {
            return (
                instanceOf(e) && (e as any)[variantOrdinalSymbol] === 9
            );
        }
    }
    class InvalidHotpDigits extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [uniffiTypeNameSymbol]: string = "Mfkdf2Error";
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [variantOrdinalSymbol] = 10;

        public readonly tag = Mfkdf2Error_Tags.InvalidHotpDigits;

        constructor(message: string) {
            super("Mfkdf2Error", "InvalidHotpDigits", message);
        }

        static instanceOf(e: any): e is InvalidHotpDigits {
            return (
                instanceOf(e) && (e as any)[variantOrdinalSymbol] === 10
            );
        }
    }
    class Argon2Error extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [uniffiTypeNameSymbol]: string = "Mfkdf2Error";
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [variantOrdinalSymbol] = 11;

        public readonly tag = Mfkdf2Error_Tags.Argon2Error;

        constructor(message: string) {
            super("Mfkdf2Error", "Argon2Error", message);
        }

        static instanceOf(e: any): e is Argon2Error {
            return (
                instanceOf(e) && (e as any)[variantOrdinalSymbol] === 11
            );
        }
    }
    class SerializeError extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [uniffiTypeNameSymbol]: string = "Mfkdf2Error";
        /**
         * @private
         * This field is private and should not be used.
         */
        readonly [variantOrdinalSymbol] = 12;

        public readonly tag = Mfkdf2Error_Tags.SerializeError;

        constructor(message: string) {
            super("Mfkdf2Error", "SerializeError", message);
        }

        static instanceOf(e: any): e is SerializeError {
            return (
                instanceOf(e) && (e as any)[variantOrdinalSymbol] === 12
            );
        }
    }

    // Utility function which does not rely on instanceof.
    function instanceOf(e: any): e is Mfkdf2Error {
        return (e as any)[uniffiTypeNameSymbol] === "Mfkdf2Error";
    }
    return {
        PasswordEmpty,
        AnswerEmpty,
        InvalidThreshold,
        MissingFactorId,
        DuplicateFactorId,
        DecodeError,
        TryFromVecError,
        ShareRecoveryError,
        InvalidHmacKey,
        InvalidHotpDigits,
        Argon2Error,
        SerializeError,
        instanceOf,
    };
})();

// Union type for Mfkdf2Error error type.


export type Mfkdf2Error = InstanceType<
    typeof Mfkdf2Error[keyof Omit<typeof Mfkdf2Error, 'instanceOf'>]
>;

const FfiConverterTypeMFKDF2Error = (() => {
    const intConverter = FfiConverterInt32;
    type TypeName = Mfkdf2Error;
    class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            switch (intConverter.read(from)) {
                case 1: return new Mfkdf2Error.PasswordEmpty(FfiConverterString.read(from)
                );
            
                case 2: return new Mfkdf2Error.AnswerEmpty(FfiConverterString.read(from)
                );
            
                case 3: return new Mfkdf2Error.InvalidThreshold(FfiConverterString.read(from)
                );
            
                case 4: return new Mfkdf2Error.MissingFactorId(FfiConverterString.read(from)
                );
            
                case 5: return new Mfkdf2Error.DuplicateFactorId(FfiConverterString.read(from)
                );
            
                case 6: return new Mfkdf2Error.DecodeError(FfiConverterString.read(from)
                );
            
                case 7: return new Mfkdf2Error.TryFromVecError(FfiConverterString.read(from)
                );
            
                case 8: return new Mfkdf2Error.ShareRecoveryError(FfiConverterString.read(from)
                );
            
                case 9: return new Mfkdf2Error.InvalidHmacKey(FfiConverterString.read(from)
                );
            
                case 10: return new Mfkdf2Error.InvalidHotpDigits(FfiConverterString.read(from)
                );
            
                case 11: return new Mfkdf2Error.Argon2Error(FfiConverterString.read(from)
                );
            
                case 12: return new Mfkdf2Error.SerializeError(FfiConverterString.read(from)
                );
            
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value: TypeName, into: RustBuffer): void {
            const obj = value as any;
            const index = obj[variantOrdinalSymbol] as number;
            intConverter.write(index, into);
        }
        allocationSize(value: TypeName): number {
            return intConverter.allocationSize(0);
        }
    }
    return new FfiConverter();
})();


// FfiConverter for Map<string, Mfkdf2Factor>
const FfiConverterMapStringTypeMFKDF2Factor = new FfiConverterMap(FfiConverterString, FfiConverterTypeMFKDF2Factor);


// FfiConverter for ArrayBuffer | undefined
const FfiConverterOptionalArrayBuffer = new FfiConverterOptional(FfiConverterArrayBuffer);


// FfiConverter for string | undefined
const FfiConverterOptionalString = new FfiConverterOptional(FfiConverterString);


// FfiConverter for /*u32*/number | undefined
const FfiConverterOptionalUInt32 = new FfiConverterOptional(FfiConverterUInt32);


// FfiConverter for /*u8*/number | undefined
const FfiConverterOptionalUInt8 = new FfiConverterOptional(FfiConverterUInt8);


// FfiConverter for Array<ArrayBuffer>
const FfiConverterArrayArrayBuffer = new FfiConverterArray(FfiConverterArrayBuffer);


// FfiConverter for Array<Mfkdf2Factor>
const FfiConverterArrayTypeMFKDF2Factor = new FfiConverterArray(FfiConverterTypeMFKDF2Factor);


// FfiConverter for Array<PolicyFactor>
const FfiConverterArrayTypePolicyFactor = new FfiConverterArray(FfiConverterTypePolicyFactor);


// FfiConverter for Array<string>
const FfiConverterArrayString = new FfiConverterArray(FfiConverterString);



/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
    // Get the bindings contract version from our ComponentInterface
    const bindingsContractVersion = 29;
    // Get the scaffolding contract version by calling the into the dylib
    const scaffoldingContractVersion = nativeModule().ubrn_ffi_mfkdf2_uniffi_contract_version();
    if (bindingsContractVersion !== scaffoldingContractVersion) {
        throw new UniffiInternalError.ContractVersionMismatch(scaffoldingContractVersion, bindingsContractVersion);
    }
    if (nativeModule().ubrn_uniffi_mfkdf2_checksum_func_derive_key() !== 2663) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_mfkdf2_checksum_func_derive_key");
    }
    if (nativeModule().ubrn_uniffi_mfkdf2_checksum_func_derive_password() !== 58970) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_mfkdf2_checksum_func_derive_password");
    }
    if (nativeModule().ubrn_uniffi_mfkdf2_checksum_func_hotp() !== 58788) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_mfkdf2_checksum_func_hotp");
    }
    if (nativeModule().ubrn_uniffi_mfkdf2_checksum_func_key() !== 8066) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_mfkdf2_checksum_func_key");
    }
    if (nativeModule().ubrn_uniffi_mfkdf2_checksum_func_setup_password() !== 21577) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_mfkdf2_checksum_func_setup_password");
    }

    }

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeFactorType,
    FfiConverterTypeHOTP,
    FfiConverterTypeHOTPHash,
    FfiConverterTypeHOTPOptions,
    FfiConverterTypeMFKDF2DerivedKey,
    FfiConverterTypeMFKDF2Entropy,
    FfiConverterTypeMFKDF2Error,
    FfiConverterTypeMFKDF2Factor,
    FfiConverterTypeMFKDF2Options,
    FfiConverterTypePassword,
    FfiConverterTypePasswordOptions,
    FfiConverterTypePolicy,
    FfiConverterTypePolicyFactor,
  }
});