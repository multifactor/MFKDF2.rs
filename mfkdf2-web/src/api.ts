// Facade over autogenerated bindings to provide ergonomic API matching reference implementation
import crypto from 'crypto';
import * as raw from './generated/web/mfkdf2.js';
export { uniffiInitAsync } from './index.web.js';
export { initRustLogging, LogLevel } from './generated/web/mfkdf2.js';

// Re-export types
export type {
  Mfkdf2DerivedKey,
  Policy,
  PolicyFactor,
  Mfkdf2Options,
  Mfkdf2Factor,
} from './generated/web/mfkdf2.js';

// Helper to convert Buffer/Uint8Array to ArrayBuffer for UniFFI
function toArrayBuffer(input: ArrayBuffer | Buffer | Uint8Array | undefined): ArrayBuffer | undefined {
  if (input === undefined) return undefined;
  if (input instanceof ArrayBuffer) return input;
  // Buffer and Uint8Array have .buffer property, but may be a view with offset
  const view = input as Uint8Array;
  return view.buffer.slice(view.byteOffset, view.byteOffset + view.byteLength) as ArrayBuffer;
}

// Wrap factor to add ergonomic API
function wrapFactor(factor: raw.Mfkdf2Factor): any {
  const getKind = () => raw.factorTypeKind(factor.factorType);

  return {
    ...factor,
    // Add type property that returns the factor kind (reference implementation compatibility)
    get type() {
      return getKind();
    },
    // Add data property that returns bytes as Buffer
    get data() {
      return Buffer.from(raw.factorTypeBytes(factor.factorType));
    },
  };
}

function wrapSetupFactor(factor: raw.Mfkdf2Factor): any {
  const wrapped = wrapFactor(factor);
  return {
    ...wrapped,
    async params(key?: ArrayBuffer) {
      const result = raw.setupFactorTypeParams(factor.factorType, key);
      // Parse JSON string returned by UniFFI (Value is serialized as string)
      return typeof result === 'string' ? JSON.parse(result) : result;
    },
    async output(key?: ArrayBuffer) {
      const result = raw.setupFactorTypeOutput(factor.factorType, key);
      // Parse JSON string returned by UniFFI (Value is serialized as string)
      return typeof result === 'string' ? JSON.parse(result) : result;
    }
  }
}

function wrapDeriveFactor(factor: raw.Mfkdf2Factor): any {
  const wrapped = wrapFactor(factor);
  return {
    ...wrapped,
    async params(key?: ArrayBuffer) {
      const result = raw.deriveFactorParams(factor.factorType, key);
      // Parse JSON string returned by UniFFI (Value is serialized as string)
      return typeof result === 'string' ? JSON.parse(result) : result;
    },
    async output() {
      const result = raw.deriveFactorOutput(factor.factorType);
      // Parse JSON string returned by UniFFI (Value is serialized as string)
      return typeof result === 'string' ? JSON.parse(result) : result;
    }
  }
}

// Wrap policy to add $id property for JSON schema compatibility
function deepParseParams(value: any): any {
  if (typeof value === 'string') {
    try {
      return deepParseParams(JSON.parse(value));
    } catch {
      return value;
    }
  }

  if (Array.isArray(value)) {
    return value.map(deepParseParams);
  }

  if (value && typeof value === 'object') {
    const parsed: any = {};
    for (const [key, nested] of Object.entries(value)) {
      parsed[key] = deepParseParams(nested);
    }
    return parsed;
  }

  return value;
}

function stringifyFactorParams(value: any): any {
  if (value === undefined || value === null) {
    return value;
  }

  if (typeof value === 'string') {
    return value;
  }

  const POLICY_ORDER = ['$id', '$schema', 'factors', 'key', 'memory', 'salt', 'threshold', 'time'];
  const FACTOR_ORDER = ['id', 'pad', 'params', 'salt', 'secret', 'type', 'hint'];

  const stringifyPolicy = (input: any): string => JSON.stringify(orderValue(input, 'policy'));

  function orderValue(input: any, context?: 'policy' | 'factor'): any {
    if (Array.isArray(input)) {
      if (context === 'policy') {
        return input.map((item) => orderValue(item, 'factor'));
      }
      return input.map((item) => orderValue(item));
    }

    if (input && typeof input === 'object') {
      const baseOrder = context === 'policy' ? POLICY_ORDER : context === 'factor' ? FACTOR_ORDER : [];
      const extras = Object.keys(input).filter((key) => !baseOrder.includes(key)).sort();
      const keys = [...baseOrder, ...extras];
      const ordered: any = {};

      for (const key of keys) {
        if (!(key in input)) continue;

        if (context === 'factor' && key === 'params') {
          const nested = input[key];
          ordered.params = typeof nested === 'string' ? nested : stringifyPolicy(nested);
          continue;
        }

        if (key === 'factors' && Array.isArray(input[key])) {
          ordered.factors = input[key].map((item: any) => orderValue(item, 'factor'));
          continue;
        }

        ordered[key] = orderValue(input[key]);
      }

      return ordered;
    }

    return input;
  }

  return stringifyPolicy(value);
}

function wrapPolicy(policy: any): any {
  const wrapped = {
    ...policy,
    $id: policy.id,
    $schema: policy.schema
  };
  delete wrapped.id;
  delete wrapped.schema;

  // console.log('wrapped factors', wrapped.factors);
  for (const factor of wrapped.factors) {
    factor.type = factor.type ?? factor.kind;
    delete factor.kind;
    factor.params = deepParseParams(factor.params);
  }

  return wrapped;
}

// TODO (@lonerapier): try to remove this
// Unwrap policy to remove $id and $schema (non-mutating)
function unwrapPolicy(policy: any): raw.Policy {
  const unwrapped: any = {
    ...policy,
    factors: policy.factors.map((f: any) => {
      const factor = { ...f };
      factor.kind = factor.type ? factor.type : factor.kind;
      delete factor.type;
      const stringified = stringifyFactorParams(factor.params);
      factor.params = stringified;
      return factor;
    })
  };

  unwrapped.id = unwrapped.$id ?? unwrapped.id;
  unwrapped.schema = unwrapped.$schema ?? unwrapped.schema;
  delete unwrapped.$id;
  delete unwrapped.$schema;

  unwrapped.time = unwrapped.time ?? 0;
  unwrapped.memory = unwrapped.memory ?? 0;

  delete unwrapped.size;

  return unwrapped;
}

// Wrap derived key to add $id to policy
function wrapDerivedKey(key: raw.Mfkdf2DerivedKey): any {
  const outputsToObject = () =>
    Object.fromEntries(Array.from(key.outputs.entries()).map(([entryKey, value]) => [entryKey, JSON.parse(value)]));

  const updateState = (updated: raw.Mfkdf2DerivedKey) => {
    key.policy = updated.policy;
    key.key = updated.key;
    key.secret = updated.secret;
    key.shares = updated.shares;
    key.outputs = updated.outputs;
    key.entropy = updated.entropy;

    wrapped.policy = wrapPolicy(key.policy);
    // refresh exposed buffers/objects to reflect latest state
    wrapped.key = Buffer.from(key.key);
    wrapped.secret = Buffer.from(key.secret);
    wrapped.shares = key.shares.map(share => Buffer.from(share));
    wrapped.entropyBits = key.entropy;
    wrapped.outputs = outputsToObject();
  };

  const applyUpdate = (updated: raw.Mfkdf2DerivedKey) => {
    updateState(updated);
    return wrapped;
  };

  const wrapped: any = {
    policy: wrapPolicy(key.policy),
    key: Buffer.from(key.key),
    secret: Buffer.from(key.secret),
    shares: key.shares.map(share => Buffer.from(share)),
    entropyBits: key.entropy,
    outputs: outputsToObject(),
    async setThreshold(threshold: number) {
      if (threshold && !Number.isInteger(threshold)) {
        throw new TypeError('threshold must be an integer');
      }

      key.policy = unwrapPolicy(key.policy);
      const updated = raw.derivedKeySetThreshold(key, threshold ?? key.policy.threshold);
      return applyUpdate(updated);
    },
    async removeFactor(factorId: string) {
      key.policy = unwrapPolicy(key.policy);
      const updated = raw.derivedKeyRemoveFactor(key, factorId);
      return applyUpdate(updated);
    },
    async removeFactors(factorIds: string[]) {
      key.policy = unwrapPolicy(key.policy);
      const updated = raw.derivedKeyRemoveFactors(key, factorIds);
      return applyUpdate(updated);
    },
    async addFactor(factor: raw.Mfkdf2Factor) {
      key.policy = unwrapPolicy(key.policy);
      const updated = raw.derivedKeyAddFactor(key, factor);
      return applyUpdate(updated);
    },
    async addFactors(factors: raw.Mfkdf2Factor[]) {
      key.policy = unwrapPolicy(key.policy);
      const updated = raw.derivedKeyAddFactors(key, factors);
      return applyUpdate(updated);
    },
    async recoverFactor(factor: raw.Mfkdf2Factor) {
      key.policy = unwrapPolicy(key.policy);
      const updated = raw.derivedKeyRecoverFactor(key, factor);
      return applyUpdate(updated);
    },
    async recoverFactors(factors: raw.Mfkdf2Factor[]) {
      key.policy = unwrapPolicy(key.policy);
      const updated = raw.derivedKeyRecoverFactors(key, factors);
      return applyUpdate(updated);
    },
    async reconstitute(remove_factors?: string[], add_factors?: raw.Mfkdf2Factor[], threshold?: number) {
      // check for integer otherwise uniffi will cast to integer
      if (threshold && !Number.isInteger(threshold)) {
        throw new TypeError('threshold must be an integer');
      }

      key.policy = unwrapPolicy(key.policy);
      const updated = raw.derivedKeyReconstitute(key, remove_factors ?? [], add_factors ?? [], threshold);
      return applyUpdate(updated);
    },
    async strengthen(time: number, memory: number) {
      // check for integer otherwise uniffi will cast to integer
      if (time && !Number.isInteger(time) || time < 0) {
        throw new TypeError('time must be a non-negative integer');
      }
      if (memory && !Number.isInteger(memory) || memory < 0) {
        throw new TypeError('memory must be a non-negative integer');
      }

      key.policy = unwrapPolicy(key.policy);
      const updated = raw.derivedKeyStrengthen(key, time, memory);
      return applyUpdate(updated);
    },
    async persistFactor(factorId: string) {
      key.policy = unwrapPolicy(key.policy);
      const updated = raw.derivedKeyPersistFactor(key, factorId);
      return Buffer.from(updated);
    },
    async addHint(factorId: string, bits?: number) {
      // check for integer otherwise uniffi will cast to integer
      if (bits && !Number.isInteger(bits)) {
        throw new TypeError('bits must be an integer');
      }

      key.policy = unwrapPolicy(key.policy);
      const updated = raw.derivedKeyAddHint(key, factorId, bits);
      return applyUpdate(updated);
    },
    async getHint(factorId: string, bits: number) {
      // check for integer otherwise uniffi will cast to integer
      if (bits && !Number.isInteger(bits)) {
        throw new TypeError('bits must be an integer');
      }

      key.policy = unwrapPolicy(key.policy);
      const updated = raw.derivedKeyGetHint(key, factorId, bits);
      return updated;
    },
    async derivePassword(purpose: string, salt: string, regex: RegExp) {
      // TODO (@lonerapier): fix this type
      let buffer = toArrayBuffer(Buffer.from(salt));
      const updated = raw.derivedKeyDerivePassword(key, purpose, buffer, regex.source);
      return updated;
    }
  };

  return wrapped;
}

export const mfkdf = {
  setup: {
    factors: {
      // Setup factors are async in reference implementation
      // Default values match reference implementation's defaults.js
      async password(password: string, options: { id?: string } = {}) {
        const factor = await raw.setupPassword(password, {
          id: options.id
        });
        return wrapSetupFactor(factor);
      },
      async hotp(options: { secret?: ArrayBuffer | Buffer, id?: string, digits?: number, hash?: raw.HashAlgorithm, issuer?: string, label?: string } = {}) {
        const factor = await raw.setupHotp({
          id: options.id,
          secret: toArrayBuffer(options.secret),
          digits: options.digits ?? 6,
          hash: options.hash ?? raw.HashAlgorithm.Sha1,
          issuer: options.issuer ?? 'MFKDF',
          label: options.label ?? 'mfkdf.com'
        });
        return wrapSetupFactor(factor);
      },
      async totp(options: { secret?: ArrayBuffer | Buffer, id?: string, digits?: number, hash?: raw.HashAlgorithm, issuer?: string, label?: string, window?: bigint, step?: bigint, time?: bigint | number, oracle?: Record<number, number> } = {}) {
        const factor = await raw.setupTotp({
          id: options.id,
          secret: toArrayBuffer(options.secret),
          digits: options.digits ?? 6,
          hash: options.hash ?? raw.HashAlgorithm.Sha1,
          issuer: options.issuer ?? 'MFKDF',
          label: options.label ?? 'mfkdf.com',
          time: options.time ? BigInt(options.time) : BigInt(Date.now()), // BUG: uniffi doesn't support optional integers
          window: options.window ?? 87600n,
          step: options.step ?? 30n,
          oracle: options?.oracle ? new Map(Object.entries(options.oracle).map(([key, value]) => [BigInt(key), value])) : undefined,
        });
        return wrapSetupFactor(factor);
      },
      async uuid(options: { uuid?: string, id?: string } = {}) {
        const factor = await raw.setupUuid({
          id: options.id,
          uuid: options.uuid
        });
        return wrapSetupFactor(factor);
      },
      async hmacsha1(options: { secret?: ArrayBuffer | Buffer, id?: string } = {}) {
        const factor = await raw.setupHmacsha1({
          id: options.id,
          secret: toArrayBuffer(options.secret)
        });
        return wrapSetupFactor(factor);
      },
      async question(answer: string, options: { question?: string, id?: string } = {}) {
        const factor = await raw.setupQuestion(answer, {
          id: options.id,
          question: options.question
        });
        return wrapSetupFactor(factor);
      },
      async ooba(options: { key?: crypto.webcrypto.CryptoKey, id?: string, length?: number, params?: Record<string, any> }) {
        const key = options.key ? await crypto.webcrypto.subtle.exportKey('jwk', options.key) : undefined;
        const keyString = JSON.stringify(key);
        const factor = await raw.setupOoba({
          id: options.id,
          key: keyString,
          length: options.length ?? 6,
          params: options.params ? JSON.stringify(options.params) : undefined
        });
        return wrapSetupFactor(factor);
      },
      async passkey(secret: ArrayBuffer | Buffer, options: { id?: string } = {}) {
        const factor = await raw.setupPasskey(toArrayBuffer(secret) || new Uint8Array(32).buffer, {
          id: options.id,
        });
        return wrapSetupFactor(factor);
      },
      async stack(factors: raw.Mfkdf2Factor[], options: { id?: string, threshold?: number, salt?: ArrayBuffer | Buffer | Uint8Array } = {}) {
        const factor = await raw.setupStack(factors, {
          id: options.id,
          threshold: options.threshold,
          salt: toArrayBuffer(options.salt)
        });
        return wrapSetupFactor(factor);
      }
    },
    async key(
      factors: raw.Mfkdf2Factor[],
      options: { id?: string; threshold?: number; salt?: ArrayBuffer | Buffer | Uint8Array, stack?: boolean, integrity?: boolean, time?: number, memory?: number } = {}
    ) {
      // BUG (@lonerapier): uniffi casts float to integer automatically so we need to check here
      if (options.time !== undefined && (!Number.isInteger(options.time) || options.time < 0)) {
        throw new TypeError('time must be a non-negative integer');
      }
      if (options.memory !== undefined && (!Number.isInteger(options.memory) || options.memory < 0)) {
        throw new TypeError('memory must be a non-negative integer');
      }
      const key = await raw.setupKey(factors, {
        id: options.id,
        threshold: options.threshold,
        salt: toArrayBuffer(options.salt),
        stack: options.stack,
        integrity: options.integrity,
        time: options.time,
        memory: options.memory
      });
      return wrapDerivedKey(key);
    }
  },
  derive: {
    factors: {
      async password(password: string) {
        return wrapDeriveFactor(await raw.derivePassword(password));
      },
      async hotp(code: number) {
        return wrapDeriveFactor(await raw.deriveHotp(code));
      },
      async uuid(uuid: string) {
        return wrapDeriveFactor(await raw.deriveUuid(uuid));
      },
      async hmacsha1(response: Buffer) {
        const buffer = toArrayBuffer(response);
        if (!buffer) throw new Error('Invalid response');
        return wrapDeriveFactor(await raw.deriveHmacsha1(buffer));
      },
      async question(answer: string) {
        return wrapDeriveFactor(await raw.deriveQuestion(answer));
      },
      async ooba(code: string) {
        return wrapDeriveFactor(await raw.deriveOoba(code));
      },
      async passkey(secret: ArrayBuffer | Buffer) {
        const buffer = toArrayBuffer(secret);
        if (!buffer) throw new Error('Invalid secret');
        return wrapDeriveFactor(await raw.derivePasskey(buffer));
      },
      async stack(factors: Record<string, any> | Map<string, any>) {
        // Convert object to Map if needed
        const factorMap = factors instanceof Map
          ? factors
          : new Map(Object.entries(factors));
        return wrapDeriveFactor(await raw.deriveStack(factorMap));
      },
      async totp(code: number, options?: { time?: bigint | number, oracle?: Record<number, number> }) {
        const factor = await raw.deriveTotp(code, {
          time: options?.time ? BigInt(options.time) : undefined,
          oracle: options?.oracle ? new Map(Object.entries(options.oracle).map(([key, value]) => [BigInt(key), value])) : undefined,
        });
        return wrapDeriveFactor(factor);
      },
      async persisted(share: ArrayBuffer | Buffer) {
        const buffer = toArrayBuffer(share);
        if (!buffer) throw new Error('Invalid share');

        return wrapDeriveFactor(await raw.derivePersisted(buffer));
      }
    },
    async key(policy: any, factors: Record<string, any> | Map<string, any>, verify?: boolean, stack?: boolean) {
      // Convert object to Map if needed
      const factorMap = factors instanceof Map
        ? factors
        : new Map(Object.entries(factors));

      const key = await raw.deriveKey(unwrapPolicy(policy), factorMap, verify, stack);
      return wrapDerivedKey(key);
    }
  },
  secrets: {
    share(secret: ArrayBuffer, threshold: number, shares: number): ArrayBuffer[] {
      // Placeholder - implement if needed in Rust
      const result: ArrayBuffer[] = [];
      for (let i = 0; i < shares; i++) {
        result.push(secret);
      }
      return result;
    },
    combine(shares: (ArrayBuffer | null)[], threshold: number, totalShares: number): ArrayBuffer {
      const validShares = shares.filter(s => s !== null) as ArrayBuffer[];
      if (validShares.length < threshold) {
        throw new Error('Not enough shares');
      }
      return validShares[0];
    }
  },
  policy: {
    async validate(policy: any) {
      return raw.policyValidate(unwrapPolicy(policy));
    },
    async setup(factor: raw.Mfkdf2Factor, options?: { id?: string, threshold?: number, salt?: ArrayBuffer | Buffer | Uint8Array, integrity?: boolean }) {
      return wrapDerivedKey(await raw.policySetup(factor, {
        id: options?.id,
        threshold: options?.threshold,
        salt: toArrayBuffer(options?.salt),
        integrity: options?.integrity
      }));
    },
    async derive(policy: any, factors: Record<string, any> | Map<string, any>, verify?: boolean) {
      const factorMap = factors instanceof Map
        ? factors
        : new Map(Object.entries(factors));

      return wrapDerivedKey(await raw.policyDerive(unwrapPolicy(policy), factorMap, verify));
    },
    async evaluate(policy: any, factorIds: string[]) {
      return await raw.policyEvaluate(unwrapPolicy(policy), factorIds);
    },
    async atLeast(n: number, factors: raw.Mfkdf2Factor[]) {
      return wrapSetupFactor(await raw.policyAtLeast(n, factors));
    },
    async all(factors: raw.Mfkdf2Factor[]) {
      return wrapSetupFactor(await raw.policyAll(factors));
    },
    async any(factors: raw.Mfkdf2Factor[]) {
      return wrapSetupFactor(await raw.policyAny(factors));
    },
    async or(factor1: raw.Mfkdf2Factor, factor2: raw.Mfkdf2Factor) {
      return wrapSetupFactor(await raw.policyOr(factor1, factor2));
    },
    async and(factor1: raw.Mfkdf2Factor, factor2: raw.Mfkdf2Factor) {
      return wrapSetupFactor(await raw.policyAnd(factor1, factor2));
    }
  }
};

export default mfkdf;