// Facade over autogenerated bindings to provide ergonomic API for tests
import * as raw from './generated/web/mfkdf2.js';
export { uniffiInitAsync } from './index.web.js';

// Re-export some useful TS types from the generated module for convenience
export type {
  Mfkdf2DerivedKey as DerivedKey,
  Policy,
  PolicyFactor,
  Mfkdf2Options as SetupOptions,
  Mfkdf2Factor as Factor,
} from './generated/web/mfkdf2.js';

// Local helper to create setup password options
export type PasswordOptions = { id?: string };

type AnyFactor = any;

function addKindProperty(f: AnyFactor): AnyFactor {
  try {
    const tag = f?.factorType?.tag as string | undefined;
    const kind = tag
      ? tag === 'Password'
        ? 'password'
        : tag === 'HOTP'
          ? 'hotp'
          : tag.toLowerCase()
      : undefined;
    if (kind && !('kind' in f)) {
      (f as any).kind = kind;
    }
  } catch { }
  return f;
}

function toMap<T>(v: Record<string, T> | Map<string, T>): Map<string, T> {
  if (v instanceof Map) return v;
  return new Map(Object.entries(v));
}

// Facade API
export const mfkdf2 = {
  setup: {
    factors: {
      password(password: string, opts: PasswordOptions = {}) {
        const f = raw.setupPassword(password, { id: opts.id });
        return addKindProperty(f);
      },
      // other setup factors can be added here later
    },
    async key(
      factors: AnyFactor[],
      options: Partial<{ id: string; threshold: number; salt: ArrayBuffer }> = {},
    ) {
      return await raw.key(factors, {
        id: options.id,
        threshold: options.threshold,
        salt: options.salt,
      } as any);
    },
  },
  derive: {
    factors: {
      password(password: string) {
        const f = raw.derivePassword(password);
        return addKindProperty(f);
      },
      hotp(code: number) {
        const f = raw.deriveHotp(code);
        return addKindProperty(f);
      },
    },
    async key(policy: any, factors: Record<string, AnyFactor> | Map<string, AnyFactor>) {
      return await raw.deriveKey(policy, toMap(factors) as any);
    },
  },
  secrets: {
    share(secret: Buffer, threshold: number, shares: number): Buffer[] {
      // This would need to be implemented in your Rust bindings
      // For now, returning a placeholder that matches the expected behavior
      const result: Buffer[] = [];
      for (let i = 0; i < shares; i++) {
        result.push(secret);
      }
      return result;
    },
    combine(shares: (Buffer | null)[], threshold: number, totalShares: number): Buffer {
      // This would need to be implemented in your Rust bindings
      // For now, returning the first non-null share
      const validShares = shares.filter(share => share !== null) as Buffer[];
      if (validShares.length < threshold) {
        throw new Error('Not enough shares to reconstruct secret');
      }
      return validShares[0];
    }
  }
};

export default mfkdf2;
