// Facade over autogenerated bindings to provide ergonomic API matching reference implementation
import * as raw from './generated/web/mfkdf2.js';
export { uniffiInitAsync } from './index.web.js';

// Re-export types
export type {
  Mfkdf2DerivedKey,
  Policy,
  PolicyFactor,
  Mfkdf2Options,
  Mfkdf2Factor,
} from './generated/web/mfkdf2.js';

// Helper to convert ArrayBuffer to Buffer for Node.js compatibility
function toBuffer(arrayBuffer: ArrayBuffer): Buffer {
  return Buffer.from(arrayBuffer);
}

// Wrap factor to add ergonomic API
function wrapFactor(factor: raw.Mfkdf2Factor): any {
  const getKind = () => raw.factorTypeKind(factor.factorType);

  return {
    ...factor,
    // Add type property that returns the factor kind (reference implementation compatibility)
    get type() {
      return getKind();
    },
    // Add data property that returns bytes as Buffer
    get data() {
      return toBuffer(raw.factorTypeBytes(factor.factorType));
    },
    // Add async params() method with optional 32-byte key
    async params(key?: ArrayBuffer) {
      const result = raw.setupFactorTypeParams(factor.factorType, key);
      // Parse JSON string returned by UniFFI (Value is serialized as string)
      return typeof result === 'string' ? JSON.parse(result) : result;
    },
    // Add async output() method with optional 32-byte key
    async output(key?: ArrayBuffer) {
      const result = raw.setupFactorTypeOutput(factor.factorType, key);
      // Parse JSON string returned by UniFFI (Value is serialized as string)
      return typeof result === 'string' ? JSON.parse(result) : result;
    }
  };
}

// Wrap policy to add $id property for JSON schema compatibility
function wrapPolicy(policy: any): any {
  if (!policy) return policy;
  return new Proxy(policy, {
    get(target, prop) {
      if (prop === '$id') return target.id;
      return target[prop];
    },
    set(target, prop, value) {
      if (prop === '$id') {
        target.id = value;
        return true;
      }
      target[prop] = value;
      return true;
    }
  });
}

// Wrap derived key to add $id to policy
function wrapDerivedKey(key: any): any {
  return {
    ...key,
    policy: wrapPolicy(key.policy),
    // Add entropyBits alias for compatibility
    get entropyBits() {
      return key.entropy;
    }
  };
}

export const mfkdf = {
  setup: {
    factors: {
      // Setup factors are async in reference implementation
      async password(password: string, options: { id?: string } = {}) {
        const factor = await raw.setupPassword(password, { id: options.id });
        return wrapFactor(factor);
      },
      async hotp(options: { secret?: ArrayBuffer, id?: string } = {}) {
        return raw.setupHotp({
          id: options.id,
          secret: options.secret,
          digits: 6,
          hash: raw.OtpHash.Sha1,
          issuer: '',
          label: ''
        });
      },
      async uuid(options: { uuid?: string, id?: string } = {}) {
        return raw.setupUuid({ id: options.id, uuid: options.uuid });
      }
    },
    async key(
      factors: any[],
      options: { id?: string; threshold?: number; salt?: ArrayBuffer } = {}
    ) {
      const key = await raw.key(factors, {
        id: options.id,
        threshold: options.threshold,
        salt: options.salt,
        stack: undefined,
        integrity: undefined,
        time: undefined,
        memory: undefined
      });
      return wrapDerivedKey(key);
    }
  },

  derive: {
    factors: {
      password(password: string) {
        return raw.derivePassword(password);
      },
      hotp(code: number) {
        return raw.deriveHotp(code);
      },
      uuid(uuid: string) {
        return raw.deriveUuid(uuid);
      }
    },
    async key(policy: any, factors: Record<string, any> | Map<string, any>) {
      // Unwrap policy proxy if needed
      const rawPolicy = policy.id ? policy : policy;

      // Convert object to Map if needed
      const factorMap = factors instanceof Map
        ? factors
        : new Map(Object.entries(factors));

      // Use derive with default verify=true
      const key = raw.derive(rawPolicy, factorMap, true);
      return wrapDerivedKey(key);
    }
  },

  secrets: {
    share(secret: ArrayBuffer, threshold: number, shares: number): ArrayBuffer[] {
      // Placeholder - implement if needed in Rust
      const result: ArrayBuffer[] = [];
      for (let i = 0; i < shares; i++) {
        result.push(secret);
      }
      return result;
    },
    combine(shares: (ArrayBuffer | null)[], threshold: number, totalShares: number): ArrayBuffer {
      const validShares = shares.filter(s => s !== null) as ArrayBuffer[];
      if (validShares.length < threshold) {
        throw new Error('Not enough shares');
      }
      return validShares[0];
    }
  }
};

export default mfkdf;