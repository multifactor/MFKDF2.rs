// Facade over autogenerated bindings to provide ergonomic API matching reference implementation
import * as raw from './generated/web/mfkdf2.js';
export { uniffiInitAsync } from './index.web.js';

// Re-export types
export type {
  Mfkdf2DerivedKey,
  Policy,
  PolicyFactor,
  Mfkdf2Options,
  Mfkdf2Factor,
} from './generated/web/mfkdf2.js';

// Helper to convert ArrayBuffer to Buffer for Node.js compatibility
function toBuffer(arrayBuffer: ArrayBuffer): Buffer {
  return Buffer.from(arrayBuffer);
}

// Helper to convert Buffer/Uint8Array to ArrayBuffer for UniFFI
function toArrayBuffer(input: ArrayBuffer | Buffer | Uint8Array | undefined): ArrayBuffer | undefined {
  if (input === undefined) return undefined;
  if (input instanceof ArrayBuffer) return input;
  // Buffer and Uint8Array have .buffer property, but may be a view with offset
  const view = input as Uint8Array;
  return view.buffer.slice(view.byteOffset, view.byteOffset + view.byteLength) as ArrayBuffer;
}

// Wrap factor to add ergonomic API
function wrapFactor(factor: raw.Mfkdf2Factor): any {
  const getKind = () => raw.factorTypeKind(factor.factorType);

  return {
    ...factor,
    // Add type property that returns the factor kind (reference implementation compatibility)
    get type() {
      return getKind();
    },
    // Add data property that returns bytes as Buffer
    get data() {
      return toBuffer(raw.factorTypeBytes(factor.factorType));
    },
    // Add async params() method with optional 32-byte key
    async params(key?: ArrayBuffer) {
      const result = raw.setupFactorTypeParams(factor.factorType, key);
      // Parse JSON string returned by UniFFI (Value is serialized as string)
      return typeof result === 'string' ? JSON.parse(result) : result;
    },
    // Add async output() method with optional 32-byte key
    async output(key?: ArrayBuffer) {
      const result = raw.setupFactorTypeOutput(factor.factorType, key);
      // Parse JSON string returned by UniFFI (Value is serialized as string)
      return typeof result === 'string' ? JSON.parse(result) : result;
    }
  };
}

// Wrap policy to add $id property for JSON schema compatibility
function wrapPolicy(policy: any): any {
  const wrapped = {
    ...policy,
    $id: policy.id,
    $schema: policy.schema
  };
  delete wrapped.id;
  delete wrapped.schema;
  return wrapped;
}

// Wrap derived key to add $id to policy
function wrapDerivedKey(key: raw.Mfkdf2DerivedKey): any {
  return {
    ...key,
    policy: wrapPolicy(key.policy),
    // Add entropyBits alias for compatibility
    get key() {
      return toBuffer(key.key);
    },
    get secret() {
      return toBuffer(key.secret);
    },
    get shares() {
      return key.shares.map(share => toBuffer(share));
    },
    // TODO (@lonerapier): check what other fields need to be casted
    get entropyBits() {
      return key.entropy;
    },
    get outputs() {
      return Object.fromEntries(Array.from(key.outputs.entries()).map(([key, value]) => [key, JSON.parse(value)]));
    }

  }
};

export const mfkdf = {
  setup: {
    factors: {
      // Setup factors are async in reference implementation
      // Default values match reference implementation's defaults.js
      async password(password: string, options: { id?: string } = {}) {
        const factor = await raw.setupPassword(password, {
          id: options.id
        });
        return wrapFactor(factor);
      },
      async hotp(options: { secret?: ArrayBuffer | Buffer, id?: string, digits?: number, hash?: raw.OtpHash, issuer?: string, label?: string } = {}) {
        const factor = await raw.setupHotp({
          id: options.id,
          secret: toArrayBuffer(options.secret),
          digits: options.digits ?? 6,
          hash: options.hash ?? raw.OtpHash.Sha1,
          issuer: options.issuer ?? 'MFKDF',
          label: options.label ?? 'mfkdf.com'
        });
        return wrapFactor(factor);
      },
      async totp(options: { secret?: ArrayBuffer | Buffer, id?: string, digits?: number, hash?: raw.OtpHash, issuer?: string, label?: string, window?: bigint, step?: bigint, time?: bigint, oracle?: number[] } = {}) {
        const factor = await raw.setupTotp({
          id: options.id,
          secret: toArrayBuffer(options.secret),
          digits: options.digits ?? 6,
          hash: options.hash ?? raw.OtpHash.Sha1,
          issuer: options.issuer ?? 'MFKDF',
          label: options.label ?? 'mfkdf.com',
          time: options.time ?? BigInt(Date.now()), // BUG: uniffi doesn't support optional integers
          window: options.window ?? 87600n,
          step: options.step ?? 30n,
          oracle: options.oracle
        });
        return wrapFactor(factor);
      },
      async uuid(options: { uuid?: string, id?: string } = {}) {
        const factor = await raw.setupUuid({
          id: options.id,
          uuid: options.uuid
        });
        return wrapFactor(factor);
      },
      async hmacsha1(options: { secret?: ArrayBuffer | Buffer, id?: string } = {}) {
        const factor = await raw.setupHmacsha1({
          id: options.id,
          secret: toArrayBuffer(options.secret)
        });
        return wrapFactor(factor);
      },
      async question(answer: string, options: { question?: string, id?: string } = {}) {
        const factor = await raw.setupQuestion(answer, {
          id: options.id,
          question: options.question
        });
        return wrapFactor(factor);
      },
      async ooba(options: { key: string, id?: string, length?: number, params?: string } = { key: '' }) {
        const factor = await raw.setupOoba({
          id: options.id ?? 'ooba',
          key: options.key,
          length: options.length ?? 6,
          params: options.params
        });
        return wrapFactor(factor);
      },
      async passkey(secret: ArrayBuffer | Buffer, options: { id?: string } = {}) {
        const factor = await raw.setupPasskey(toArrayBuffer(secret) || new Uint8Array(32).buffer, {
          id: options.id,
        });
        return wrapFactor(factor);
      },
      async stack(factors: raw.Mfkdf2Factor[], options: { id?: string, threshold?: number, salt?: ArrayBuffer | Buffer | Uint8Array } = {}) {
        const factor = await raw.setupStack(factors, {
          id: options.id,
          threshold: options.threshold,
          salt: toArrayBuffer(options.salt)
        });
        return wrapFactor(factor);
      }
    },
    async key(
      factors: raw.Mfkdf2Factor[],
      options: { id?: string; threshold?: number; salt?: ArrayBuffer | Buffer | Uint8Array, stack?: boolean, integrity?: boolean, time?: number, memory?: number } = {}
    ) {
      const key = await raw.key(factors, {
        id: options.id,
        threshold: options.threshold,
        salt: toArrayBuffer(options.salt),
        stack: options.stack,
        integrity: options.integrity,
        time: options.time,
        memory: options.memory
      });
      return wrapDerivedKey(key);
    }
  },
  derive: {
    factors: {
      async password(password: string) {
        return wrapFactor(await raw.derivePassword(password));
      },
      async hotp(code: number) {
        return wrapFactor(await raw.deriveHotp(code));
      },
      async uuid(uuid: string) {
        return wrapFactor(await raw.deriveUuid(uuid));
      },
      async hmacsha1(response: ArrayBuffer) {
        return wrapFactor(await raw.deriveHmacsha1(response));
      },
      async question(answer: string) {
        return wrapFactor(await raw.deriveQuestion(answer));
      },
      async ooba(code: string) {
        return wrapFactor(await raw.deriveOoba(code));
      },
      async passkey(secret: ArrayBuffer | Buffer) {
        return wrapFactor(await raw.derivePasskey(toArrayBuffer(secret) || new Uint8Array(32).buffer)); // TODO (@lonerapier): fix
      },
      async stack(factors: Record<string, any> | Map<string, any>) {
        // Convert object to Map if needed
        const factorMap = factors instanceof Map
          ? factors
          : new Map(Object.entries(factors));
        return wrapFactor(await raw.deriveStack(factorMap));
      },
      async totp(code: number, options?: raw.TotpOptions) {
        return wrapFactor(await raw.deriveTotp(code, options));
      }
    },
    async key(policy: raw.Policy, factors: Record<string, any> | Map<string, any>, verify?: boolean, stack?: boolean) {
      // Convert object to Map if needed
      const factorMap = factors instanceof Map
        ? factors
        : new Map(Object.entries(factors));

      const key = await raw.deriveKey(policy, factorMap, verify, stack);
      return wrapDerivedKey(key);
    }
  },
  secrets: {
    share(secret: ArrayBuffer, threshold: number, shares: number): ArrayBuffer[] {
      // Placeholder - implement if needed in Rust
      const result: ArrayBuffer[] = [];
      for (let i = 0; i < shares; i++) {
        result.push(secret);
      }
      return result;
    },
    combine(shares: (ArrayBuffer | null)[], threshold: number, totalShares: number): ArrayBuffer {
      const validShares = shares.filter(s => s !== null) as ArrayBuffer[];
      if (validShares.length < threshold) {
        throw new Error('Not enough shares');
      }
      return validShares[0];
    }
  }
};

export default mfkdf;